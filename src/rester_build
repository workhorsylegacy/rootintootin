#!/usr/bin/env python2.6

import os, shutil
from lib_rester import *

# Make sure the first arg is a path
if len(sys.argv) != 2:
	print "usage: ./build 'working directory'"
	exit(1)
elif not os.path.exists(sys.argv[1]):
	print "The path '" + sys.argv[1] + "' does not exist. Exiting ..."
	exit(1)

# Move the path to the location of the current file
os.chdir(os.sys.path[0])

def combine_code_files(routes, table_map, reference_map):
	# Open the output file
	out_file = open('run.d', 'w')

	# Write the imports
	out_file.write(
		"\n" +
		"import tango.text.convert.Integer;\n" +
		"import tango.text.Util;\n" +
		"import tango.io.Stdout;\n" +
		"import tango.text.Regex;\n" +
		"import tango.time.chrono.Gregorian;\n" +
		"import tango.time.WallClock;\n" +

		"\n" +
		"import language_helper;\n" +
		"import helper;\n" +
		"import rester;\n" +
		"import rester_server;\n" +
		"import ui;\n\n"
	);

	# Write the generated model base classes into the file
	for model in os.listdir('app/models/'):
		if not model.endswith('.d'):
			continue

		model_name = str.split(model, '.')[0]
		model_map = table_map[model_name + 's']

		out_file.write("\n\n")
		out_file.write(model_generated_properties_class(model_name, model_map, reference_map))
		out_file.write("\n\n")

	# Write the models into the file
	for model in os.listdir('app/models/'):
		if not model.endswith('.d'):
			continue

		model_name = str.split(model, '.')[0]
		model_map = table_map[model_name + 's']

		f = open('app/models/' + model, 'r')
		out_file.write("\n\n")
		out_file.write(f.read())
		out_file.write("\n\n")
		f.close()

	# Write the controllers into the file
	for controller, actions in routes.items():
		f = open('app/controllers/' + controller + '_controller.d', 'r')
		out_file.write("\n\n")
		out_file.write(f.read())
		out_file.write("\n\n")
		f.close()

	# Write the layouts into the file
	for layout in os.listdir('app/views/layouts/'):
		if not layout.endswith('.d'):
			continue
		layout = layout[0:-2]

		f = open('app/views/layouts/' + layout + '.d', 'r')
		out_file.write("\n\n")
		out_file.write(f.read())
		out_file.write("\n\n")
		f.close()

	# Write the views into the file
	for controller, actions in routes.items():
		all_actions = {}
		all_actions.update(actions['member'])
		all_actions.update(actions['collection'])
		for member, http_method in all_actions.items():
			if not os.path.exists('app/views/' + controller + '/' + member + '.d'):
				continue

			f = open('app/views/' + controller + '/' + member + '.d', 'r')
			out_file.write("\n\n")
			out_file.write(f.read())
			out_file.write("\n\n")
			f.close()


	# Write the runner class
	out_file.write(
	"public class Runner : RunnerBase {\n")
	for controller, actions in routes.items():
		out_file.write("	private " + controller.capitalize() + "Controller _" + controller + "_controller;\n")
	out_file.write("\n")

	# Write the render view function
	out_file.write(
	"public char[] render_view(char[] controller_name, char[] view_name) {\n" +
	"	int[int] line_translations;\n")

	for controller, actions in routes.items():
		out_file.write(
		"	if(controller_name == \"" + controller + "s\") {\n")

		all_actions = {}
		all_actions.update(actions['member'])
		all_actions.update(actions['collection'])
		for action, method in all_actions.items():
			if method == "get":
				out_file.write(
				"		if(view_name == \"" + action.capitalize() + "\" || view_name == \"" + action.lower() + "\") {\n" +
				"			return " + controller.capitalize() + action.capitalize() + "View.render(this._" + controller + "_controller, line_translations);\n"
				)

				out_file.write("		}\n")

		out_file.write("	}\n")
	out_file.write("	return \"Unknown view '\" ~ view_name ~ \"'\";\n")
	out_file.write("}\n")


	# Write the run action function
	out_file.write(
	"public char[] run_action(Request request) {\n" +
	"\n"
	)
	
	for controller, actions in routes.items():
		out_file.write(
		"	if(request.controller == \"" + controller + "s\") {\n" +
		"		this._" + controller + "_controller = new " + controller.capitalize() + "Controller();\n" +
		"		this._" + controller + "_controller.request = request;\n" +
		"\n"
		)

		all_actions = {}
		all_actions.update(actions['member'])
		all_actions.update(actions['collection'])
		for action, method in all_actions.items():
			if action == "new":
				action = "New"
			elif action == "delete":
				action = "Delete"
			out_file.write(
			"		if(request.action == \"" + action + "\") {\n" +
			"			this._" + controller + "_controller." + action + "();\n"
			)

			if method == "get":
				out_file.write(
				"			return this.render_view(request.controller, request.action);\n"
				)
			else:
				out_file.write(
				"			return null;\n"
				)

			out_file.write("		}\n")

		out_file.write("	}\n")

	out_file.write("	return null;\n")
	out_file.write("}\n")
	out_file.write("}\n")

	port = globals()['server_configuration']['port']
	event_port = None
	if globals()['server_configuration'].has_key('event_port'):
		event_port = globals()['server_configuration']['event_port']
	max_connections = globals()['server_configuration']['max_connections']
	header_max_size = globals()['server_configuration']['header_max_size']
	db_host = globals()['database_configuration']['host']
	db_user = globals()['database_configuration']['user']
	db_password = globals()['database_configuration']['password']
	db_name = globals()['database_configuration']['name']

	# Write the main function
	if event_port:
		out_file.write(
		"\n\nint main() {\n" +
		"	Server server = new Server();\n" + 
		"	char[" + str(header_max_size) + "] buffer;\n" + 
		"	char[" + str(header_max_size) + "] event_buffer;\n" + 
		"	RunnerBase runner = new Runner();\n" + 
		"	RunnerBase event_runner = new Runner();\n\n" + 
		"	server.start(" + str(port) + ", " + str(event_port) + ", " + str(max_connections) + ", \n" + 
		"				buffer, event_buffer, " + str(header_max_size) + ", \n" + 
		"				\"" + db_host + "\", \"" + db_user + "\", \n" + 
		"				\"" + db_password + "\", \"" + db_name + "\",\n" +
		"				runner, event_runner);\n" +
		"\n" +
		"	return 0;\n" +
		"}\n")
	else:
		out_file.write(
		"\n\nint main() {\n" +
		"	Server server = new Server();\n" + 
		"	char[" + str(header_max_size) + "] buffer;\n\n" + 
		"	server.start(" + str(port) + ", " + str(max_connections) + ", \n" + 
		"				buffer, " + str(header_max_size) + ", \n" + 
		"				\"" + db_host + "\", \"" + db_user + "\", \n" + 
		"				\"" + db_password + "\", \"" + db_name + "\",\n" +
		"				new Runner());\n" +
		"\n" +
		"	return 0;\n" +
		"}\n")

def model_generated_properties_class(model_name, model_map, reference_map):
	# Add class opening
	properties = "public class " + model_name.capitalize() + "ModelBase : ModelBase {\n"
	properties += "	mixin ModelBaseMixin!(" + model_name.capitalize() + ", \"" + model_name + "\");\n\n"

	# Add a list of all field names
	properties += "	private static char[][] _field_names = ["
	for field, values in model_map.items():
		properties += "\"" + field + "\", ";
	properties += "];\n\n";

	# Add a list of the unique field names
	properties += "	private static char[][] _unique_field_names = ["
	for field, values in model_map.items():
		if field == "id":
			continue
		properties += "\"" + field + "\", ";
	properties += "];\n\n";

	# Add all the fields
	for field, values in model_map.items():
		if not field.endswith('_id'):
			properties += "	private " + sql_type_to_d_type(values['type']) + " _" + field + ";\n"

	# Add the field properties
	for field, values in model_map.items():
		if field.endswith('_id'):
			continue

		# Add getter
		properties += \
						"	// " + values['type'] + "\n" + \
						"	public " + sql_type_to_d_type(values['type']) + " " + field + "() {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		return _" + field + ";\n" + \
						"	}\n"
		# Add setter, but not for id
		if field != 'id':
			properties += \
						"	public void " + field + "(" + sql_type_to_d_type(values['type']) + " value) {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		_" + field + " = value;\n" + \
						"	}\n"

	# Add the belongs_to references
	for table_name, has_manys in reference_map.iteritems():
		table_name = table_name[:-1]
		for has_many in has_manys:
			if has_many[:-1] == model_name:
				properties += \
						"	private " + table_name.capitalize() + "ModelBase _" + table_name + " = null;\n" + \
						"\n" + \
						"	public void parent(" + table_name.capitalize() + "ModelBase value) {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		_" + table_name + " = value;\n" + \
						"	}\n" + \
						"	public " + table_name.capitalize() + "ModelBase parent() {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		return _" + table_name + ";\n" + \
						"	}\n"
	
	# Add the has_many references
	table_name = model_name + 's'
	if table_name in reference_map:
		for has_many in reference_map[table_name]:
			has_many = has_many[:-1]
			properties += \
					"	private class " + has_many.capitalize() + "s {\n" + \
					"		mixin ModelArrayMixin!(" + model_name.capitalize() + "ModelBase, \n" + \
					"								" + has_many.capitalize() + "ModelBase);\n" + \
					"	}\n" + \
					"\n" + \
					"	private " + has_many.capitalize() + "s _" + has_many + "s;\n\n" + \
					"	public void after_this() {\n" + \
					"		_" + has_many + "s = new " + has_many.capitalize() + "s(\n" + \
 					"		" + has_many.capitalize() + "ModelBase.find_all(_model_name ~ \"_id = \" ~ to_s(_id))\n" + \
					"		);\n" + \
					"	}\n\n" + \
					"	public void " + has_many + "s(" + has_many.capitalize() + "s value) {\n" + \
					"		ensure_was_pulled_from_database();\n" + \
					"		_" + has_many + "s = value;\n" + \
					"	}\n" + \
					"	public " + has_many.capitalize() + "s " + has_many + "s() {\n" + \
					"		ensure_was_pulled_from_database();\n" + \
					"		return _" + has_many + "s;\n" + \
					"	}\n"


	# Add the set_field_by_name method
	properties += \
				"	public void set_field_by_name(char[] field_name, char[] value, bool must_check_database_first = true) {\n" + \
				"		if(must_check_database_first)\n" + \
				"			ensure_was_pulled_from_database();\n\n" + \
				"		switch(field_name) {\n"

	for field, values in model_map.items():
		if field.endswith('_id'):
			reference_type = field.split('_id')[0]
			value_with_cast = convert_string_to_d_type(sql_type_to_d_type(values['type']), 'value')
			properties += \
					"			case \"" + field + "\":\n" + \
					"				_" + reference_type + " = new " + reference_type.capitalize() + "();\n" + \
					"				_" + reference_type + ".set_field_by_name(\"id\", value, false);\n" + \
					"				_" + reference_type + "._was_pulled_from_database = false;\n" + \
					"				break;\n"
		else:
			value_with_cast = convert_string_to_d_type(sql_type_to_d_type(values['type']), 'value')
			properties += \
					"			case \"" + field + "\":\n" + \
					"				_" + field + " = " + value_with_cast + ";\n" + \
					"				break;\n"

	properties += \
				"			default:\n" + \
				"				break;\n" + \
				"		}\n" + \
				"	}\n"

	# Add the get_field_by_name method
	properties += \
				"	public char[] get_field_by_name(char[] field_name) {\n" + \
				"		switch(field_name) {\n"

	# tango.text.convert.Integer.parse.toString
	for field, values in model_map.items():
		if field.endswith('_id'):
			reference_type = field.split('_id')[0]
			value_to_string = convert_d_type_to_string(sql_type_to_d_type(values['type']), "_" + field)
			properties += \
					"			case \"" + field + "\":\n" + \
					"				return _" + reference_type + " is null ? null : to_s(_" + reference_type + ".id);\n"
		else:
			value_to_string = convert_d_type_to_string(sql_type_to_d_type(values['type']), "this." + field)
			properties += \
					"			case \"" + field + "\":\n" + \
					"				return " + value_to_string + ";\n"

	properties += \
				"			default:\n" + \
				"				break;\n" + \
				"		}\n" + \
				"		return null;\n" + \
				"	}\n"

	# Add class closing
	properties += "}"

	return properties


def generate_models():
	# Connect to the database
	db = MySQLdb.connect(host = globals()['database_configuration']['host'], 
						user = globals()['database_configuration']['user'], 
						passwd = globals()['database_configuration']['password'], 
						db = globals()['database_configuration']['name'])

	# Get all the tables
	table_map = {}
	cursor = db.cursor()
	cursor.execute("show tables;")
	result = cursor.fetchall()
	for row in result:
		table_map[row[0]] = {}
	cursor.close()

	# Get the fields for each table
	for table in table_map:
		cursor = db.cursor()
		cursor.execute('desc ' + table + ';')
		result = cursor.fetchall()

		for row in result:
			field = row[0]

			table_map[table][field] = {}
			table_map[table][field]['type'] = row[1]
			table_map[table][field]['null'] = row[2]
			table_map[table][field]['key'] = row[3]
			table_map[table][field]['default'] = row[4]
			table_map[table][field]['extra'] = row[5]

		cursor.close()

	# Add the relationships to the table
	reference_map = {}
	for table, fields in table_map.items():
		cursor = db.cursor()
		query = "select column_name, referenced_table_name, referenced_column_name from " + \
				"information_schema.key_column_usage where " + \
				"table_schema='" + globals()['database_configuration']['name'] + "' " + \
				"and table_name='" + table + "' and " + \
				"referenced_table_name is not null and referenced_column_name is not null;"
		cursor.execute(query)
		result = cursor.fetchall()

		for row in result:
			column_name, referenced_table_name, referenced_column_name = row
			if not referenced_table_name in reference_map:
				reference_map[referenced_table_name] = []
			reference_map[referenced_table_name].append(table)

		cursor.close()

	return table_map, reference_map

def generate_views(routes):
	for controller, actions in routes.items():
		all_actions = {}
		all_actions.update(actions['member'])
		all_actions.update(actions['collection'])
		for member, http_method in all_actions.items():
			# If there is no template, then skip it
			if not os.path.exists('app/views/' + controller + '/' + member + '.html.ed'):
				continue

			# Get the template file as a string
			f = open('app/views/' + controller + '/' + member + '.html.ed', 'r')
			body = f.read()
			f.close()

			# Print the openining of the function
			output = []
			output.append(
			"public class " + controller.capitalize() + member.capitalize() + "View { \n" +
			"public static char[] render(" + controller.capitalize() + "Controller controller, out int[int] line_translations) { \n" +
			"	// Generate the view as an array of strings\n" +
			"	AutoStringArray builder = new AutoStringArray();")

			process_template_body(body, output)

			# Print the closing of the function
			output.append(
			"\n" +
			"	if(controller.use_layout) {\n" + 
			"		return DefaultLayout.render(controller, tango.text.Util.join(builder.value, \"\")); \n" + 
			"	} else {\n" + 
			"		return tango.text.Util.join(builder.value, \"\"); \n" + 
			"	}\n"
			"}\n" +
			"}\n")

			# Save the output as a D file
			out_file = open('app/views/' + controller + '/' + member + '.d', 'w')
			for fragment in output:
				out_file.write(fragment)
			out_file.close()



def generate_layouts():
	for layout in os.listdir('app/views/layouts/'):
		if not layout.endswith('.html.ed'):
			continue
		layout = layout[0:-8]

		# Get the layout file as a string
		f = open('app/views/layouts/' + layout + '.html.ed', 'r')
		body = f.read()
		f.close()

		# Print the openining of the function
		output = []
		output.append(
		"public class " + layout.capitalize() + "Layout { \n" +
		"public static char[] render(ControllerBase controller, char[] yield) { \n" +
		"	// Generate the layout as an array of strings\n" +
		"	AutoStringArray builder = new AutoStringArray();")

		process_template_body(body, output)

		# Print the closing of the function
		output.append(
		"\n	return tango.text.Util.join(builder.value, \"\"); \n" +
		"}\n" +
		"}\n")

		# Save the output as a D file
		out_file = open('app/views/layouts/' + layout + '.d', 'w')
		for fragment in output:
			out_file.write(fragment)
		out_file.close()

def process_template_body(body, output):
	while len(body) > 0:
		# Get the location on the open and close brackets
		open_index = body.find("<%")
		close_index = body.find("%>")

		# raise if open but no close
		# raise if close before open

		# If there were no brackets, just print the last text as a string
		if open_index == -1 and close_index == -1:
			output.append("\n	builder ~= \"" + body.replace("\"", "\\\"") + "\"; ")
			break

		# Get the text before, after, and in between the brackets
		before = body[: open_index]
		middle = body[open_index+2 : close_index]
		after = body[close_index+2 :]

		# If there was text before the opening, print it as a string
		if len(before) > 0:
			output.append("\n	builder ~= \"" + before.replace("\"", "\\\"") + "\"; ")

		# Print the code between the brackets
		if len(middle) > 0:
			if middle[0] == "=":
				output.append("\n	builder ~= " + middle[1:] + ";")
			else:
				output.append("\n	" + middle)

		# Set the remaining text as the body, so it can be processed next
		body = after

# Copy all the framework and app files into a scratch dir
pwd = sys.argv[1]
scratch = pwd + '/scratch/'
if os.path.exists(scratch):
	shutil.rmtree(scratch)
shutil.copytree(os.sys.path[0], scratch)
if os.path.exists(pwd+'/app/'):
	shutil.copytree(pwd+'/app/', scratch+'app/')
if os.path.exists(pwd+'/config/'):
	shutil.copytree(pwd+'/config/', scratch+'config/')
if os.path.exists(pwd+'/db/'):
	shutil.copytree(pwd+'/db/', scratch+'db/')
os.chdir(scratch)

# Get the routes
exec_file("config/routes.py", globals(), locals())
exec_file("config/config.py", globals(), locals())

# Do code generation
generate_layouts()
generate_views(routes)
table_map, reference_map = generate_models()
combine_code_files(routes, table_map, reference_map)

# Compile the application into an executable
result = ""
result += pexpect.run("gcc -g -c db.c -o db.o")
result += pexpect.run("ar rcs db.a db.o")
command = "ldc -g -of run " + \
			"language_helper.d helper.d rester.d rester_server.d ui.d run.d db.d " + \
			"db.a -L=\"-lmysqlclient\""
result += pexpect.run(command)

if len(result) != 0:
	print result
else:
	print "Build successful."





