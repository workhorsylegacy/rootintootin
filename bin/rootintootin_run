#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#-------------------------------------------------------------------------------
#
#    This file is part of the Rootin Tootin web framework and licensed under the
#    GPL version 3 or greater. See the COPYRIGHT file for copyright information.
#    This project is hosted at http://rootin.toot.in .
#
#-------------------------------------------------------------------------------

import os, sys, shutil, signal, subprocess
import threading, time
import errno
import functools
import commands
import json
from lib_rootintootin import *


# Make sure the first arg is a path
if len(sys.argv) != 3:
	print "usage: ./build 'working directory' [server|application]"
	exit(1)
elif not os.path.exists(sys.argv[1]):
	print "The path '" + sys.argv[1] + "' does not exist. Exiting ..."
	exit(1)

# Move the path to the location of the current file
os.chdir(os.sys.path[0])

def generate_app(version, routes, table_map, reference_map):
	generator = Generator()

	# Get the names of all the views
	view_names = []
	for controller_name, route_maps in routes.items():
		for entry in os.listdir('app/views/' + controller_name):
			if entry.endswith('.html.ed'):
				view_names.append('view_' + controller_name + '_' + entry.split('.html.ed')[0])

	# Open the output file
	out_file = open('application.d', 'w')

	# Write the imports
	out_file.write(
		"\n" +
		"private import tango.io.Stdout;\n" +
		"private import tango.io.device.File;\n" +
		"private import tango.text.json.Json;\n\n" +
		"private import language_helper;\n" +
		"private import helper;\n" +
		"private import regex;\n" +
		"private import rootintootin;\n" +
		"private import rootintootin_server;\n" +
		"private import rootintootin_process;\n\n"
	)

	for controller_name, route_maps in routes.items():
		out_file.write("private import " + generator.singularize(controller_name) + "_controller;\n")
	out_file.write("\n")

	for view_name in view_names:
		out_file.write("private import " + view_name + ";\n")
	out_file.write("\n")

	# Write the runner class
	out_file.write(
	"public class Runner : RunnerBase {\n")

	# Write the render view function
	for controller, route_maps in routes.items():
		out_file.write(
		"	private string generate_view(" + generator.singularize(controller).capitalize() + "Controller controller, string controller_name, string view_name) {\n")

		out_file.write(
		"		if(controller_name == \"" + generator.pluralize(controller) + "\") {\n")

		for action, route_map in route_maps.items():
			for uri, method in route_map.items():
				if method == "GET":
					out_file.write(
					"			if(view_name == \"" + action.capitalize() + "\" || view_name == \"" + action.lower() + "\") {\n" +
					"				return " + controller.capitalize() + action.capitalize() + "View.render(controller);\n" +
					"			}\n"
					)

		out_file.write("		}\n")
		out_file.write("		return \"Unknown view '\" ~ view_name ~ \"'\";\n")
		out_file.write("	}\n")


	# Write the run action function
	out_file.write(
	"	public string run_action(Request request, string controller_name, string action_name, string id, out string[] events_to_trigger) {\n")
	for controller, route_maps in routes.items():
		out_file.write(
		"		if(controller_name == \"" + generator.pluralize(controller) + "\") {\n" +
		"			" + generator.singularize(controller).capitalize() + "Controller controller = new " + generator.singularize(controller).capitalize() + "Controller();\n" + 
		"			controller.action_name = action_name;\n" + 
		"			controller.controller_name = controller_name;\n" + 
		"			controller.request = request;\n" + 
		"			try {\n" +
		"				switch(action_name) {\n"
		)

		for action, route_map in route_maps.items():
			real_action = action
			if action == "new":
				real_action = "New"
			elif action == "delete":
				real_action = "Delete"
			out_file.write(
				"					case \"" + action + "\": controller." + real_action + "(); break;\n")

		out_file.write(
			"					default: throw new RenderNoActionException();\n" + 
			"				}\n")
		out_file.write(
			"			} catch(RenderViewException err) {\n" + 
			"				return this.generate_view(controller, controller_name, err._name);\n" + 
			"			} finally {\n" + 
			"				events_to_trigger = controller._events_to_trigger;\n" + 
			"			}\n")
		out_file.write("		}\n")

	links = []
	for controller_name, route_maps in routes.items():
		links.append("\"" + controller_name + "\"")

	out_file.write(
	"		throw new RenderNoControllerException([" + str.join(', ', links) + "]);\n"
	)

	out_file.write("	}\n")
	out_file.write("}\n")

	port = str(int(globals()['server_configuration']['port']))
	max_waiting_clients = globals()['server_configuration']['max_waiting_clients']
	header_max_size = globals()['server_configuration']['header_max_size']
	db_host = globals()['database_configuration']['host']
	db_user = globals()['database_configuration']['user']
	db_password = globals()['database_configuration']['password']
	db_name = globals()['database_configuration']['name']

	# Write the main function header
	out_file.write(
	"\n\nint main() {\n")

	# Write the routes
	out_file.write(
	"	// Create the routes\n" + 
	"	string[Regex][string][string] routes;\n")
	for controller_name, route_maps in routes.iteritems():
		for action_name, route_map in route_maps.iteritems():
			for uri, method in route_map.iteritems():
				out_file.write("	routes[\"" + controller_name + "\"][\"" + action_name + "\"][new Regex(r\"" + uri + "\")] = \"" + method + "\";\n")

	# Write the server start in main
	out_file.write("""
	// Read the config from the config file
	auto file = new File("config/config.json", File.ReadExisting);
	auto content = new char[cast(size_t)file.length];
	file.read(content);
	file.close();
	auto values = (new Json!(char)).parse(content).toObject();

	string[string][string] config;
	foreach(n1, v1; values.attributes()) {
		foreach(n2, v2; v1.toObject().attributes()) {
			config[n2] = null;
			foreach(n3, v3; v2.toObject().attributes()) {
				config[n2][n3] = v3.toString();
			}
		}
	}

	// Create and start the app
	RunnerBase runner = new Runner();
	auto app = new RootinTootinAppProcess(
				"Rootin_Tootin_0.6.0", 
				runner, routes, 
				config["database_configuration"]["host"], 
				config["database_configuration"]["user"], 
				config["database_configuration"]["password"], 
				config["database_configuration"]["name"]);
	app.start();

	return 0;
}
""")

def model_generated_properties_class(model_name, model_map, reference_map, model_names):
	generator = Generator()
	# Add class opening
	properties = \
			"private import rootintootin;\n" + \
			"private import tango.text.json.Json;\n" + \
			"private import tango.text.xml.Document;\n" + \
			"private import tango.text.xml.DocPrinter;\n\n"

	for entry in model_names:
		properties += "private import " + entry + ";\n"
		if model_name != entry:
			properties += "private import " + entry + "_base;\n"
	properties += "\n"

	properties += "public class " + model_name.capitalize() + "Base : ModelBase {\n"
	properties += "	mixin ModelBaseMixin!(" + model_name.capitalize() + ", \"" + model_name + "\", \""+ generator.pluralize(model_name) + "\");\n\n"

	# Add a list of all field names
	properties += "	protected static string[] _field_names = ["
	for field, values in model_map.items():
		properties += "\"" + field + "\", ";
	properties += "];\n\n";

	# Add a list of the unique field names
	properties += "	protected static string[] _unique_field_names = ["
	for field, values in model_map.items():
		if field == "id":
			continue
		properties += "\"" + field + "\", ";
	properties += "];\n\n";

	# Add all the fields with default values
	for field, values in model_map.items():
		if not field.endswith('_id'):
			properties += "	protected " + sql_type_to_d_type(values['type']) + " _" + field + " = " + sql_type_to_default_d_value(values['type']) + ";\n"

	# Add the field properties
	for field, values in model_map.items():
		if field.endswith('_id'):
			continue

		# Add getter
		properties += \
						"	// " + values['type'] + "\n" + \
						"	public " + sql_type_to_d_type(values['type']) + " " + field + "() {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		return _" + field + ";\n" + \
						"	}\n"
		# Add setter, but not for id
		if field != 'id':
			properties += \
						"	public void " + field + "(" + sql_type_to_d_type(values['type']) + " value) {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		_" + field + " = value;\n" + \
						"	}\n"

	# Add the belongs_to references
	for table_name, has_manys in reference_map.iteritems():
		table_name = table_name[:-1]
		for has_many in has_manys:
			if has_many[:-1] == model_name:
				properties += \
						"	protected " + table_name.capitalize() + "Base _" + table_name + " = null;\n" + \
						"\n" + \
						"	public void parent(" + table_name.capitalize() + "Base value) {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		_" + table_name + " = value;\n" + \
						"	}\n" + \
						"	public " + table_name.capitalize() + "Base parent() {\n" + \
						"		ensure_was_pulled_from_database();\n" + \
						"		return _" + table_name + ";\n" + \
						"	}\n"
	
	# Add the has_many references
	table_name = generator.pluralize(model_name)
	if table_name in reference_map:
		for has_many in reference_map[table_name]:
			has_many = has_many[:-1]
			has_manies = generator.pluralize(has_many)
			properties += \
					"	protected class " + has_many.capitalize() + "s {\n" + \
					"		mixin ModelArrayMixin!(" + model_name.capitalize() + "Base, \n" + \
					"								" + has_many.capitalize() + "Base);\n" + \
					"	}\n" + \
					"\n" + \
					"	protected " + has_manies.capitalize() + " _" + has_manies + ";\n\n" + \
					"	public void after_this() {\n" + \
					"		_" + has_manies + " = new " + has_manies.capitalize() + "(\n" + \
 					"		" + has_many.capitalize() + "Base.find_all(_model_name ~ \"_id = \" ~ to_s(_id))\n" + \
					"		);\n" + \
					"	}\n\n" + \
					"	public void " + has_manies + "(" + has_manies.capitalize() + " value) {\n" + \
					"		ensure_was_pulled_from_database();\n" + \
					"		_" + has_manies + " = value;\n" + \
					"	}\n" + \
					"	public " + has_manies.capitalize() + " " + has_manies + "() {\n" + \
					"		ensure_was_pulled_from_database();\n" + \
					"		return _" + has_manies + ";\n" + \
					"	}\n"


	# Add the set_field_by_name method
	properties += \
				"	public void set_field_by_name(string field_name, string value, bool must_check_database_first = true) {\n" + \
				"		if(must_check_database_first)\n" + \
				"			ensure_was_pulled_from_database();\n\n" + \
				"		switch(field_name) {\n"

	for field, values in model_map.items():
		if field.endswith('_id'):
			reference_type = field.split('_id')[0]
			value_with_cast = convert_string_to_d_type(sql_type_to_d_type(values['type']), 'value')
			properties += \
					"			case \"" + field + "\":\n" + \
					"				_" + reference_type + " = new " + reference_type.capitalize() + "();\n" + \
					"				_" + reference_type + ".set_field_by_name(\"id\", value, false);\n" + \
					"				_" + reference_type + "._was_pulled_from_database = false;\n" + \
					"				break;\n"
		else:
			value_with_cast = convert_string_to_d_type(sql_type_to_d_type(values['type']), 'value')
			properties += \
					"			case \"" + field + "\":\n" + \
					"				_" + field + " = " + value_with_cast + ";\n" + \
					"				break;\n"

	properties += \
				"			default:\n" + \
				"				break;\n" + \
				"		}\n" + \
				"	}\n"

	# Add the get_field_by_name method
	properties += \
				"	public string get_field_by_name(string field_name) {\n" + \
				"		switch(field_name) {\n"

	for field, values in model_map.items():
		if field.endswith('_id'):
			reference_type = field.split('_id')[0]
			value_to_string = convert_d_type_to_string(sql_type_to_d_type(values['type']), "_" + field)
			properties += \
					"			case \"" + field + "\":\n" + \
					"				return _" + reference_type + " is null ? null : to_s(_" + reference_type + ".id);\n"
		else:
			value_to_string = convert_d_type_to_string(sql_type_to_d_type(values['type']), "this." + field)
			properties += \
					"			case \"" + field + "\":\n" + \
					"				return " + value_to_string + ";\n"

	properties += \
				"			default:\n" + \
				"				break;\n" + \
				"		}\n" + \
				"		return null;\n" + \
				"	}\n"

	# Add the to_json method
	properties += \
				"	public string to_json() {\n" + \
				"		auto json = new Json!(char);\n" + \
				"		with(json)\n" + \
				"			value = object(pair(\"" + model_name + "\", object(\n"

	model_map_len = len(model_map)
	for field, values in model_map.items():
		comma = ", "
		if model_map_len == 1:
			comma = ""
		if field.endswith('_id'):
			reference_type = field.split('_id')[0]
			properties += \
				"						pair(\"" + field + "\", value(_" + reference_type + ".id))" + comma + "\n"
		elif values['type'].startswith('decimal'):
			properties += \
				"						pair(\"" + field + "\", value(_" + field + ".toDouble()))" + comma + "\n"
		else:
			properties += \
				"						pair(\"" + field + "\", value(_" + field + "))" + comma + "\n"
		model_map_len -= 1

	properties += \
				"			)));\n" + \
				"\n" + \
				"		char[] data = \"\";\n" + \
				"		json.print((char[] s) {\n" + \
				"			data ~= s;\n" + \
				"		});\n" + \
				"		return data;\n" + \
				"	}\n"

	# Add the to_xml method
	properties += \
				"	public string to_xml() {\n" + \
				"		auto doc = new Document!(char);\n" + \
				"		auto top = doc.tree.element(null, \"" + model_name + "\");\n" + \
				"\n"

	for field, values in model_map.items():
		if field.endswith('_id'):
			reference_type = field.split('_id')[0]
			properties += \
				"		top.element(null, \"" + field + "\")\n" + \
				"			.data(to_s(_" + reference_type + ".id))\n" + \
				"			.attribute(null, \"type\", \"" + sql_type_to_xml_type(values['type']) + "\");\n"
		else:
			properties += \
				"		top.element(null, \"" + field + "\")\n" + \
				"			.data(to_s(_" + field + "))\n" + \
				"			.attribute(null, \"type\", \"" + sql_type_to_xml_type(values['type']) + "\");\n"

	properties += \
				"\n" + \
				"		auto print = new DocPrinter!(char);\n" + \
				"		return print(doc);\n" + \
				"	}\n"

	# Add class closing
	properties += "}"

	return properties


def generate_models():
	# Connect to the database
	generator = Generator()
	db = None
	try:
		db = MySQLdb.connect(host = globals()['database_configuration']['host'], 
							user = globals()['database_configuration']['user'], 
							passwd = globals()['database_configuration']['password'], 
							db = globals()['database_configuration']['name'])
	except MySQLdb.OperationalError, err:
		if err.args[0] == 2002:
			print "Can't connect to the mysql server. Make sure it is running. Exiting ..."
		elif err.args[0] == 1045:
			print "Can't log into the mysql server. Make sure the user name and password are correct in config/config.json. Exiting ..."
		else:
			print "MySQL error# " + str(err.args[0]) + " : " + err.args[1]
		exit()

	# Get all the tables
	table_map = {}
	cursor = db.cursor()
	cursor.execute("show tables;")
	result = cursor.fetchall()
	for row in result:
		table_map[row[0]] = {}
	cursor.close()

	# Get the fields for each table
	for table in table_map:
		cursor = db.cursor()
		cursor.execute('desc ' + table + ';')
		result = cursor.fetchall()

		for row in result:
			field = row[0]

			table_map[table][field] = {}
			table_map[table][field]['type'] = row[1]
			table_map[table][field]['null'] = row[2]
			table_map[table][field]['key'] = row[3]
			table_map[table][field]['default'] = row[4]
			table_map[table][field]['extra'] = row[5]

		cursor.close()

	# Add the relationships to the table
	reference_map = {}
	for table, fields in table_map.items():
		cursor = db.cursor()
		query = "select column_name, referenced_table_name, referenced_column_name from " + \
				"information_schema.key_column_usage where " + \
				"table_schema='" + globals()['database_configuration']['name'] + "' " + \
				"and table_name='" + table + "' and " + \
				"referenced_table_name is not null and referenced_column_name is not null;"
		cursor.execute(query)
		result = cursor.fetchall()

		for row in result:
			column_name, referenced_table_name, referenced_column_name = row
			if not referenced_table_name in reference_map:
				reference_map[referenced_table_name] = []
			reference_map[referenced_table_name].append(table)

		cursor.close()

	# Get the names of all the models
	model_names = []
	for entry in os.listdir('app/models/'):
		if entry.endswith('.d'):
			model_names.append(str.split(entry, '.')[0])

	# Write the generated model base classes into the files
	for model_name in model_names:
		model_map = table_map[generator.pluralize(model_name)]

		with open(model_name + '_base.d', 'w') as f:
			f.write("\n\n")
			f.write(model_generated_properties_class(model_name, model_map, reference_map, model_names))
			f.write("\n\n")

		with open('app/models/' + model_name + '.d', 'r') as f_in:
			with open(model_name + '.d', 'w') as f_out:
				f_out.write(f_in.read())

	return table_map, reference_map

def generate_controllers():
	for controller in os.listdir('app/controllers/'):
		if not controller.endswith('.d'):
			continue

		with open('app/controllers/' + controller, 'r') as f_in:
			with open(controller, 'w') as f_out:
				f_out.write(f_in.read())

def generate_views(routes):
	generator = Generator()

	# Get the names of all the models
	model_names = []
	for entry in os.listdir('app/models/'):
		if entry.endswith('.d'):
			model_names.append(str.split(entry, '.')[0])

	for controller, route_maps in routes.items():
		for member, route_map in route_maps.items():
			# If there is no template, then skip it
			if not os.path.exists('app/views/' + controller + '/' + member + '.html.ed'):
				continue

			# Get the template file as a string
			f = open('app/views/' + controller + '/' + member + '.html.ed', 'r')
			body = f.read()
			f.close()

			# Print the openining of the function
			output = []
			output.append(
			"private import rootintootin;" +
			"private import ui;")

			for model_name in model_names:
				output.append("private import " + generator.singularize(model_name) + ";")

			for controller_name, route_maps in routes.items():
				output.append("private import " + generator.singularize(controller_name) + "_controller;")

			output.append(
			"private import view_layouts_default;" +
			"public class " + controller.capitalize() + member.capitalize() + "View { " +
			"public static string render(" + generator.singularize(controller).capitalize() + "Controller controller) { " +
			"set_controller(controller);"
			"AutoStringArray b = new AutoStringArray();")

			process_template_body(body, output)

			# Print the closing of the function
			output.append(
			"\n" +
			"	if(controller.use_layout) {\n" + 
			"		return DefaultLayout.render(controller, b.toString()); \n" + 
			"	} else {\n" + 
			"		return b.toString(); \n" + 
			"	}\n"
			"}\n" +
			"}\n")

			# Save the output as a D file
			out_file = open('view_' + controller + '_' + member + '.d', 'w')
			for fragment in output:
				out_file.write(fragment)
			out_file.close()

def generate_layouts():
	for layout in os.listdir('app/views/layouts/'):
		if not layout.endswith('.html.ed'):
			continue
		layout = layout[0:-8]

		# Get the layout file as a string
		f = open('app/views/layouts/' + layout + '.html.ed', 'r')
		body = f.read()
		f.close()

		# Print the openining of the function
		output = []
		output.append(
		"private import rootintootin;" +
		"private import ui;" +
		"public class " + layout.capitalize() + "Layout { " +
		"public static string render(ControllerBase controller, string yield) { " +
		"AutoStringArray b = new AutoStringArray();")

		process_template_body(body, output)

		# Print the closing of the function
		output.append(
		"\n	return b.toString(); \n" +
		"}\n" +
		"}\n")

		# Save the output as a D file
		out_file = open('view_layouts_' + layout + '.d', 'w')
		for fragment in output:
			out_file.write(fragment)
		out_file.close()

def get_link_files(routes):
	generator = Generator()
	files = []

	# Get the names of all the models
	model_names = []
	for entry in os.listdir('app/models/'):
		if entry.endswith('.d'):
			model_names.append(str.split(entry, '.')[0])

	# Get the names of all the views
	view_names = []
	for controller_name, route_maps in routes.items():
		for entry in os.listdir('app/views/' + controller_name):
			if entry.endswith('.html.ed'):
				view_names.append('view_' + controller_name + '_' + entry.split('.html.ed')[0])

	for model_name in model_names:
		files.append(model_name + '_base.d')
	for model_name in model_names:
		files.append(model_name + '.d')
	for controller_name, route_maps in routes.items():
		files.append(generator.singularize(controller_name) + '_controller.d')
	for view_name in view_names:
		files.append(view_name + '.d')
	files.append('view_layouts_default.d')

	return files

def process_template_body(body, output):
	while len(body) > 0:
		# Get the location on the open and close brackets
		open_index = body.find("<%")
		close_index = body.find("%>")

		# raise if open but no close
		# raise if close before open

		# If there were no brackets, just print the last text as a string
		if open_index == -1 and close_index == -1:
			output.append(" b~= \"" + body.replace("\"", "\\\"") + "\";")
			break

		# Get the text before, after, and in between the brackets
		before = body[: open_index]
		middle = body[open_index+2 : close_index]
		after = body[close_index+2 :]

		# If there was text before the opening, print it as a string
		if len(before) > 0:
			output.append(" b~= \"" + before.replace("\"", "\\\"") + "\";")

		# Print the code between the brackets
		if len(middle) > 0:
			if middle[0] == "=":
				output.append(" b~= h(" + middle[1:] + ");")
			elif middle[0] == "#":
				output.append(" b~= " + middle[1:] + ";")
			else:
				output.append(" " + middle)

		# Set the remaining text as the body, so it can be processed next
		body = after

def setup_app(pwd, scratch):
	# Remove all the old app files
	if os.path.exists(scratch+'app/'):
		shutil.rmtree(scratch+'app/')
	if os.path.exists(scratch+'config/'):
		shutil.rmtree(scratch+'config/')
	if os.path.exists(scratch+'db/'):
		shutil.rmtree(scratch+'db/')
	if os.path.exists(scratch+'public/'):
		shutil.rmtree(scratch+'public/')
	if os.path.exists(scratch+'uploads/'):
		shutil.rmtree(scratch+'uploads/')

	# Copy all the app files into a scratch dir
	if os.path.exists(pwd+'/app/'):
		shutil.copytree(pwd+'/app/', scratch+'app/')
	if os.path.exists(pwd+'/config/'):
		shutil.copytree(pwd+'/config/', scratch+'config/')
	if os.path.exists(pwd+'/db/'):
		shutil.copytree(pwd+'/db/', scratch+'db/')
	if os.path.exists(pwd+'/public/'):
		shutil.copytree(pwd+'/public/', scratch+'public/')
	os.mkdir(scratch+'uploads/')
	os.chdir(scratch)

	# Load the config files
	with open('config/routes.json', 'r') as f:
		globals()['routes'] = json.loads(f.read())["routes"]

	with open('config/config.json', 'r') as f:
		config = json.loads(f.read())["config"]
		globals()['database_configuration'] = config['database_configuration']
		globals()['server_configuration'] = config['server_configuration']

	# Get the Rootin Tootin version
	f = open(scratch+'version')
	version = f.read().strip()
	f.close()

	# Do code generation
	table_map, reference_map = generate_models()
	generate_controllers()
	generate_layouts()
	generate_views(routes)
	generate_app(version, routes, table_map, reference_map)

# FIXME: This does not need to be a thread anymore, as we don't rebuild the server
class BuilderThread(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self._server_pid = None
		self._is_running = False
		self._project_dir = sys.argv[1] + '/app/'
		self._compile_error = None

	def set_is_running(self, value):
		self._is_running = value

	def get_is_running(self):
		return self._is_running

	def get_compile_error(self):
		return self._compile_error

	def run(self):
		self._is_running = True

		while self._is_running:
			time.sleep(3)

		self._kill_server()

	def _kill_server(self):
		# Kill the previous server
		if self._server_pid:
			os.kill(self._server_pid, signal.SIGHUP)
			self._server_pid = None

	def _build_server(self):
		print "Rebuilding server ..."
		self._kill_server()

		# Get all the locations
		rootintootin_dir = os.path.expanduser('~/.rootintootin')
		project_name = sys.argv[1].split('/')[-1]
		pwd = sys.argv[1]
		scratch = rootintootin_dir + '/' + project_name + '/scratch/'

		# Copy all the framework files into a scratch dir
		if not os.path.exists(rootintootin_dir):
			os.mkdir(rootintootin_dir)
		if os.path.exists(scratch):
			shutil.rmtree(scratch)
		shutil.copytree(os.sys.path[0]+'/../src/', scratch)
		shutil.copytree(os.sys.path[0]+'/../dornado/', scratch+'dornado')

		setup_app(pwd, scratch)
		self._port = int(globals()['server_configuration']['port'])

		# Compile the application into an executable
		additional_imports = get_link_files(routes)

		tango = "-I /usr/include/d/ldc/ -L /usr/lib/d/libtango-user-ldc.a"

		result = ''
		result += commands.getoutput("gcc -g -c -Wall -Werror db.c -o db.o")
		result += commands.getoutput("gcc -g -c -Wall -Werror file_system.c -o file_system.o")
		result += commands.getoutput("gcc -g -c -Wall -Werror regex.c -o regex.o -lpcre")
		result += commands.getoutput("gcc -g -c -Wall -Werror shared_memory.c -o shared_memory.o")
		result += commands.getoutput("gcc -g -c -Wall -Werror socket.c -o socket.o")
		result += commands.getoutput("ar rcs rootintootin_clibs.a db.o file_system.o regex.o shared_memory.o socket.o")
		command = "ldc -g -w -c language_helper.d helper.d rootintootin.d " + \
				"ui.d rootintootin_server.d http_server.d tcp_server.d " + \
				"rootintootin_process.d app_builder.d dornado/ioloop.d " + \
				" db.d file_system.d regex.d shared_memory.d socket.d " + tango
		result += commands.getoutput(command)

		command = "ar rcs rootintootin.a language_helper.o helper.o " + \
				"rootintootin.o ui.o rootintootin_server.o http_server.o " + \
				"tcp_server.o rootintootin_process.o app_builder.o ioloop.o " + \
				"db.o file_system.o regex.o shared_memory.o socket.o"
		result += commands.getoutput(command)

		command = "ldc -g -w -of server server.d -L rootintootin.a " + \
				"-L rootintootin_clibs.a -L=\"-lmysqlclient\" -L=\"-lpcre\" " + tango
		result += commands.getoutput(command)

		if os.path.exists("server"):
			self._compile_error = None
			print "Server build successful!"
		else:
			self._compile_error = result
			print "Server build failed!"
			print self._compile_error
			exit()

		# Run the server in its own process
		self._server_pid = subprocess.Popen([scratch + "server", pwd]).pid

# Build and start the server
if sys.argv[2] == 'server':
	builder_thread = BuilderThread()
	builder_thread._build_server()
	try:
		builder_thread.start()
		while True:
			time.sleep(1)
	except KeyboardInterrupt:
		print "Exiting ..."
		builder_thread.set_is_running(False)
# Or build the application
elif sys.argv[2] == 'application':
	# Get all the locations
	rootintootin_dir = os.path.expanduser('~/.rootintootin')
	project_name = sys.argv[1].split('/')[-1]
	pwd = sys.argv[1]
	scratch = rootintootin_dir + '/' + project_name + '/scratch/'

	setup_app(pwd, scratch)
else:
	print "invalid option " + sys.argv[2]


